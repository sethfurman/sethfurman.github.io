---
layout: post
title:  "A Red-Black Tree Implementation in C"
date:   2017-05-13
author: Seth Furman
categories: programming c
---

Overview
--------
As part of my systems programming course, I completed a project that had us
implement a dynamic memory allocation library in C. Our library would manage a
given block of memory (a heap) with analogs of the standard library functions
`malloc`, `realloc`, and `free`.

To make our implementation time-efficent (and for fun) I decided to implement a
Red-Black Tree (RBT), which would be used as follows:
- Each RBT node is the header of a block of memory (managed by a heap).
- Nodes (i.e. blocks) that are in the tree are implicitly free, while those not
  in the tree are implicitly in use.
- A heap's RBT is sorted by block capacity.

With this setup, we can fulfill memory allocation requests by removing the
smallest node of (at least) the requested size and returning a pointer to the
start of its block. Blocks would likewise be freed by coalescing them with
adjacent free blocks and adding them to the tree.
- Note that we can reduce the amount of unused memory generated by allocation
  requests by cleaving excess memory off of the end of a removed node, forming
  it into a new node, and re-adding it to the tree.

RBT Implementation
------------------
Below is the header file for my Red-Black Tree implementation, which defines
the interface. As mentioned below, the actual implementation was based on
[Professor Lyn Turbak's "Red-Black Trees" handout][turbak-rbt.pdf],
while `RBT_pretty_print` was based on an [implementation][tree-pretty-print]
written by [VasyaNovikov][vasyanovikov] (which was "inspired by the 'tree'
command in linux").

To see my full implementation and tests (which should run on either Mac OS X or
Linux) check out the GitHub repository
{% include icon-github.html username="sfurman3" %} /
[red-black-tree-c](https://github.com/sfurman3/red-black-tree-c).

```c
{% include source/rbt.h %}
```

[turbak-rbt.pdf]: /assets/documents/red-black.pdf
[vasyanovikov]: https://stackoverflow.com/users/1091436/vasyanovikov
[tree-pretty-print]: #vasyanovikov-implementation

<h3 id="vasyanovikov-implementation">
VasyaNovikov's tree pretty-printing implementation
</h3>

<h4>Output example</h4>
<pre style="line-height: 1.0;">
└── z
    ├── c
    │   ├── a
    │   └── b
    ├── d
    ├── e
    │   └── asdf
    └── f
</pre>

<h4>Code -- Java</h4>
```java
public class TreeNode {

    final String name;
    final List<TreeNode> children;

    public TreeNode(String name, List<TreeNode> children) {
        this.name = name;
        this.children = children;
    }

    public void print() {
        print("", true);
    }

    private void print(String prefix, boolean isTail) {
        System.out.println(prefix + (isTail ? "└── " : "├── ") + name);
        for (int i = 0; i < children.size() - 1; i++) {
            children.get(i).print(prefix + (isTail ? "    " : "│   "), false);
        }
        if (children.size() > 0) {
            children.get(children.size() - 1)
                    .print(prefix + (isTail ?"    " : "│   "), true);
        }
    }
}
```
